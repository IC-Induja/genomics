{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Genomics","title":"Home"},{"location":"#genomics","text":"","title":"Genomics"},{"location":"docs/AminoAcids/","text":"AminoAcids AminoAcids(self, seq, **kwargs) Properties get_aa AminoAcids.get_aa(self, start, stop, index=1) Arguments Returns reverse_translate AminoAcids.reverse_translate(self, as_rna=False, codon_table=None, codon_usage=None) Arguments Returns","title":"AminoAcids"},{"location":"docs/Annotation/","text":"Annotation Annotation(self, annotation_data, region=None, start=None, stop=None, strand=None) Properties","title":"Annotation"},{"location":"docs/AnnotationTable/","text":"AnnotationTable AnnotationTable(self, keep_cds_annotations=False, use_headers=None) Properties get_genes AnnotationTable.get_genes(self) Arguments Returns list of Gene : list of Gene objects, representing each gene in the annotation table filter AnnotationTable.filter(self, fn, col=None) Arguments Returns filter_type AnnotationTable.filter_type(self, type) Arguments Returns filter_region AnnotationTable.filter_region(self, region=None, start=None, stop=None, strand=None) Arguments Returns apply AnnotationTable.apply(self, fn, col=None) Arguments Returns save_as AnnotationTable.save_as(self, path, filetype=None, overwrite_existing=False) Arguments Returns","title":"AnnotationTable"},{"location":"docs/DNA/","text":"DNA DNA(self, data, annotations=None, key=None, key_type=None, start_index=1, accepted_chars=None, double_stranded=True, ignore_numbers_and_spaces=True) Abstract sequence class. Properties key (str): Identifier. Must be unique within a genome. If none is provided, uses a uuid. key_type (str): Source of identifier. data (str): Sequence contents. start_index (int): Index representing first position in data. Default 1 (as 1-indexing is common in biology). is_double_stranded (bool): Indicates whether sequence has complementary strand. Default True. find DNA.find(self, query, strand=None) locates query in sequence. Arguments query (string) : string to search for strand (string) : One of {'+', '-'}. If provided, find will only search the given strand. Returns Region : location of first match on sequence count DNA.count(self, query) Arguments Returns find_pattern DNA.find_pattern(self, pattern, all=False) Arguments Returns count_pattern DNA.count_pattern(self, pattern, include_overlapping=False) Arguments Returns get_dna DNA.get_dna(self, region) Arguments Returns get_rna DNA.get_rna(self, region) Arguments Returns get_aa DNA.get_aa(self, region, codon_table={}) Arguments Returns to_rna DNA.to_rna(self, region=None, start=None, stop=None, strand=None) Arguments Returns to_aa DNA.to_aa(self, codon_table=None) Arguments Returns get_genes DNA.get_genes(self) Using annotations, determine all genes contained in this sequence. This includes determining their exons, introns, and 5' and 3' UTRs Returns GeneTable : get_amino_acids DNA.get_amino_acids(self) Using annotations, determine all amino acid chains (polypeptides) produced by this sequence. Returns SequenceSet<AminoAcids> : Amino acid chains. Raises ValueError : Sequence does not contain annotations. Annotations are required to determine amino acids. get_coding_rnas DNA.get_coding_rnas(self, as_dna=False) Arguments Returns get_noncoding_rnas DNA.get_noncoding_rnas(self, as_dna=False) Arguments Returns get_cds DNA.get_cds(self, combine_by_gene=True) Arguments Returns","title":"DNA"},{"location":"docs/DisjointRegion/","text":"DisjointRegion DisjointRegion(self, start, stop, strand) Properties get_regions DisjointRegion.get_regions(self) Get Regions contained in DisjointRegion get_superset DisjointRegion.get_superset(self) Arguments Returns end5 DisjointRegion.end5(self) Arguments Returns end3 DisjointRegion.end3(self) Arguments Returns","title":"DisjointRegion"},{"location":"docs/Gene/","text":"Gene Gene(self, **kwargs) Gene. Located on DNA or RNA sequence. Properties id start stop strand sequence get_utr5 Gene.get_utr5(self) Arguments Returns get_utr3 Gene.get_utr3(self) Arguments Returns get_exon Gene.get_exon(self, exon_number, index=1) Arguments Returns get_exons Gene.get_exons(self) Arguments Returns get_intron Gene.get_intron(self, intron_number, index=1) Arguments Returns get_introns Gene.get_introns(self, intron_number, index=1) Arguments Returns","title":"Gene"},{"location":"docs/GeneTable/","text":"GeneTable GeneTable(self, **kwargs) Properties","title":"GeneTable"},{"location":"docs/Genome/","text":"Genome Genome(self, sequences) Properties calculate_gc Genome.calculate_gc(self) Arguments Returns get_genes Genome.get_genes(self) Arguments Returns get_transcripts Genome.get_transcripts(self) Arguments Returns get_proteins Genome.get_proteins(self) Arguments Returns","title":"Genome"},{"location":"docs/RNA/","text":"RNA RNA(self, data, annotations=None, key=None, key_type=None, start_index=1, accepted_chars=None, double_stranded=True) Properties get_dna RNA.get_dna(self, region) Arguments Returns get_rna RNA.get_rna(self, region) Arguments Returns get_amino_acids RNA.get_amino_acids(self, region, codon_table={}) Arguments Returns convert_to_dna RNA.convert_to_dna(self, region=None) Arguments Returns convert_to_amino_acids RNA.convert_to_amino_acids(self, region=None, codon_table=None) Arguments Returns","title":"RNA"},{"location":"docs/Region/","text":"BaseRegion BaseRegion(self, start, stop, strand=None, sequence_key=None) Is contiguous get_start BaseRegion.get_start(self) Arguments Returns get_stop BaseRegion.get_stop(self) Arguments Returns LinearRegion LinearRegion(self, start, stop, strand=None, sequence=None) Description of a region on a linear sequence. Properties start (int): Coordinate of furthest base at 5' end of Region stop (int): Coordinate of furthest base at 3' end of Region strand (str, None): One of {'+', '-', None}. Defaults to None. sequence (str, None): Id of sequence that Region is on. Defaults to None. shift LinearRegion.shift(self, bases, direction=None) Arguments Returns expand LinearRegion.expand(self, upstream, downstream) Arguments Returns slice LinearRegion.slice(self, start, stop) Arguments Returns end5 LinearRegion.end5(self) Arguments Returns end3 LinearRegion.end3(self) Arguments Returns as_positive_strand LinearRegion.as_positive_strand(self) Arguments Returns as_negative_strand LinearRegion.as_negative_strand(self) Arguments Returns as_opposite_strand LinearRegion.as_opposite_strand(self) Arguments Returns intersects LinearRegion.intersects(self, other_region) Arguments Returns contains LinearRegion.contains(self, other_region) Arguments Returns is_within LinearRegion.is_within(self, other_region) Arguments Returns CircularRegion CircularRegion(self, start, stop, strand=None, sequence=None) Description of a contiguous region on a circular sequence, where the last base immediately precedes the first. Properties start (int): Coordinate of base at 5' end of Region stop (int): Coordinate of base at 3' end of Region strand (str, None): One of {'+', '-', None}. Defaults to None. sequence (str, None): Id of sequence that Region is on. Defaults to None. shift CircularRegion.shift(self, bases, direction=None) Arguments Returns expand CircularRegion.expand(self, upstream, downstream) Arguments Returns slice CircularRegion.slice(self, start, stop) Arguments Returns end5 CircularRegion.end5(self) Arguments Returns end3 CircularRegion.end3(self) Arguments Returns as_positive_strand CircularRegion.as_positive_strand(self) Arguments Returns as_negative_strand CircularRegion.as_negative_strand(self) Arguments Returns as_opposite_strand CircularRegion.as_opposite_strand(self) Arguments Returns intersects CircularRegion.intersects(self, other_region) Arguments Returns contains CircularRegion.contains(self, other_region) Arguments Returns is_within CircularRegion.is_within(self, other_region) Arguments Returns Region Region(self, start, stop, strand=None, sequence_key=None) Wrapper providing abstraction for circular or linear region.","title":"Region"},{"location":"docs/RegionTable/","text":"RegionTable RegionTable(self) Properties from_file RegionTable.from_file(path, sep='\\t', start_col='start', end_col='end', strand_col='strand', sequence_key_col=('key', 'accession')) Should be able to pull regions from tabular files with start and end columns (as well as optional strand and sequence_key columns) from_db RegionTable.from_db() Arguments Returns save_as RegionTable.save_as(self, path, format=None, overwrite_existing=False) Arguments Returns","title":"RegionTable"},{"location":"docs/Sequence/","text":"Sequence Sequence(self, data, annotations=None, key=None, key_type=None, start_index=1, accepted_chars=None) Base class for annotated sequence. Attributes data (str) : Sequence contents. annotations (AnnotationTable) : Description of sequence features. Defaults to None. key (str) : Identifier. Must be unique within a Genome or other SequenceSet. If None, uses a uuid. (Randomly generated unique identifier.) key_type (str) : Source of key. Defaults to None. start_index (int) : Index representing first position in data. Default 1 (1-indexing is common in biology). is_circular (bool) : Indicates whether last index in sequence immediately precedes the first (ie. whether sequence forms a circle). accepted_chars (str) : Characters that are allowed in the sequence data. Ex. If accepted_chars='ATCG', then a sequence containing 'N' would raise a ValueError. Defaults to None, which accepts all alphabet characters, but not numbers or symbols. description (str) : Information about the sequence. Useful for storing non-identifier data found in certain file formats (Ex. In FASTA headers). metadata (dict) : Key-value pairs that provide information about the sequence. Useful for storing the extensive metadata found in certain file formats (ex. Genbank files). _is_reference (bool) : Indicates whether sequence is directly from reference database, and has not been modified. _reference_id (string) : ID of sequence in reference db _reference_db (string) : Well-known biological database from which the sequence was retrieved. Library currently supports NCBI, EMBL, and DDBJ. _index_in_reference(int) : Position of first element of this sequence in the reference sequence (uses 1-indexing for the referencing) from_file Sequence.from_file(start=None, stop=None, filetype=None, key=None, key_type=None, start_index=1, with_annotations=True, accepted_chars=None) Reads sequence data from file. Accepts a variety of biological formats (FASTA, Genbank, etc.). Also can read a raw sequence from .txt Accepted File Extensions: FASTA: .fa, .fasta, .fna, .ffa, .frn, .faa Genbank: .gb, .gbk GFF: .gff, .gff3 Plain Text: .txt Note: If file contains multiple sequences, use a SequenceSet instead. (Multiple sequences will raise ValueError) Arguments path (str) : Location of file (absolute or relative path, or a URL) format (str) : Format of file contents. One of the accepted file extensions listed above, or one of {fasta, gff, genbank, plaintext} If not provided, will be inferred from file extension. If gff is provided, sequence must be at the bottom of the file, beneath annotations with_annotations (bool) : if False, all annotation data in the sequence file (ex. from a GFF containing a sequence) is ignored. Returns One of { Sequence, DNASequence, RNASequence, AminoAcidSequence } : sequence contained in file, with type determined by file contents Raises FileNotFoundError : if either path or annotation_path cannot be found ValueError : if file format is not understood if with_annotations is False but annotation_path is specified if key_type is specified and does not equal uuid, but key is not specified from_db Sequence.from_db(start=None, stop=None, db='ncbi', key_type='accession', start_index=1, with_annotations=True, accepted_chars=None) Constructs a sequence by fetching data from a commonly used biological database. Currently supports NCBI. EMBL, and DDBJ databases to be added in future. Supported Key Types: NCBI: 'accession' - also known as the accession.version number. If no version is provided, the latest version will be used. However, use of accessions without version is strongly discouraged , as it reduces the reproducibility of the code. ncbi_gi - to be added in future. Arguments key (string) : Unique identifier for sequences in target db. Ex. Accession Number start (int) : Index of first base to be included in the sequence (if entire sequence is not desired) stop (int) : Index of last base to be included in the sequence (if entire sequence is not desired) db (string) : One of {'ncbi', 'ddbj', 'embl'}. ( Currently only 'ncbi' is supported. ) Major biological database. Use a db that contains the desired sequence. with_annotations (bool) : If true, retrieve annotation data in addition to the sequence data. start_index (int) : Index to use for first first character in the sequence file. Defaults to 1. Returns Sequence, or one of its subclasses DNA, RNA, or AminoAcids : sequence contained in file, with type determined from db and retrieved data Raises ValueError : reindex Sequence.reindex(self, new_start_index) Set a new start index for the sequence, and adjust start and end of sequence annotations accordingly (so that the annotations stay at the same position relative the sequence, and cover the same part of the data). Useful for converting between 0-indexing and 1-indexing. Arguments new_start_index (int) : index to use for first position in sequence data. Returns Sequence : Sequence with new start index, and all annotations adjusted to reflect the new index get_subsequence Sequence.get_subsequence(self, region=None, start=None, stop=None, reindex=False, start_index=None) Gets subset of sequence. Note: subsequence is inclusive of both start and end indices. Arguments start (int) : index of first subsequence element. Defaults to start of parent sequence. stop (int) : index of last subsequence element. Defaults to end of parent sequence. reindex (bool) : if true, index of subsequence will start at 1. Otherwise, indexing will be unchanged (ie. index to get first element in subsequence will be the same as the index in the parent sequence, and so on). start_index : Index of first element in sequence. find Sequence.find(self, query, strand=None, all=False) locates query in sequence. Arguments query (string) : string to search for strand (string) : One of {'+', '-', None}. If specified, find will only search the given strand. Returns Region/list of Region : location of first match on sequence, or, if all=True, a list containing locations of all matches count Sequence.count(self, query, overlapping=True) counts instances of query in sequence. Arguments query (string) : string to search for overlapping (bool) : include overlapping instances of query Returns int : number of occurrences of query in sequence find_pattern Sequence.find_pattern(self, pattern, all=False) Arguments Returns count_pattern Sequence.count_pattern(self, pattern, include_overlapping=False) Arguments Returns compute_distance Sequence.compute_distance(self, regionA, regionB, fn='levhenstein') Arguments Returns apply_variants Sequence.apply_variants(self, variant_data) applies one or more variants (Variant, Iterable , or VariantTable) if given string, it will open variant file at that path save_as Sequence.save_as(self, path, filetype=None, overwrite_existing=False) Arguments Returns save_sequence Sequence.save_sequence(self, path, filetype=None, overwrite_existing=False) Arguments Returns save_annotations Sequence.save_annotations(self, path, filetype=None, overwrite_existing=False) Arguments Returns","title":"Sequence"},{"location":"docs/SequenceSet/","text":"SequenceSet SequenceSet(self, sequences, start_index=None) Abstract class for a collection of sequences. Properties id (str): Identifier. If none is provided, uses a uuid. id_type (str): Source of identifier. sequences (list of sequences): Genome contents. start_index (int): TODO annotations (AnnotationTable): table containing all annotations, created by concatenating the individual AnnotationTable for every Sequence in the SequenceSet from_file SequenceSet.from_file(filetype=None) Arguments Returns reindex SequenceSet.reindex(self) Arguments Returns get_subset SequenceSet.get_subset(self, slice) Arguments Returns find SequenceSet.find(self, query, limit=1) Arguments Returns count SequenceSet.count(self, query) Arguments Returns find_pattern SequenceSet.find_pattern(self, pattern, limit=1, overlapping=True) Arguments Returns count_pattern SequenceSet.count_pattern(self, pattern) Arguments Returns compute_distance SequenceSet.compute_distance(self, regionA, regionB, fn='levhenstein') Arguments Returns apply_variant SequenceSet.apply_variant(self, genomic_variant) Arguments Returns save_as SequenceSet.save_as(self, path, filetype=None, overwrite_existing=False) Arguments Returns save_sequences SequenceSet.save_sequences(self, path, filetype=None, overwrite_existing=False) Arguments Returns save_annotations SequenceSet.save_annotations(self, path, filetype=None, overwrite_existing=False) Arguments Returns DNASet DNASet(self, sequences, start_index=None) SequenceSet with DNA-specific methods for fetching and storing calculate_gc DNASet.calculate_gc(self) Arguments Returns from_db DNASet.from_db(db='ncbi', key_type='accession', with_annotations=True, start_index=1, allowed_chars=None, start_col='start', end_col=('end', 'stop'), key_col=('key', 'accession'), keys_from_file=False, tabular_file=False) Fetches multiple sequences or sequence subsets from external db Compatible with multiple ways of specifying data. When keys_from_file=False : - If data_specification is iterable of strings, each string should be an key for a distinct sequence in the db. - If data_specification is iterable of tuples, each tuple should be in the format (key, start, stop) where: - key is the db key for the sequence - start is the index of the first element to be included - end is the index of the last element to be included. If stop is omitted, uses index of last element in db sequence. If both start and stop are omitted, entire sequence will be used. When keys_from_file=True : - if data_specification is string, should be a path or url to either: - if from_tabular_file=False : a file containing a list of db keys - if from_tabular_file=True : a tabular file with a column containing db keys, an (optional) column containing start indexes, and an (optional) column containing stop indexes - if data_specification is pandas DataFrame, if should contain a column of data keys, (optional) column of start indexes and (optional) column of stop indexes Arguments data_specification (iterable, str, or pd.DataFrame) : sequences specified in the above format Returns Raises ValueError : RNASet RNASet(self, sequences, start_index=None) SequenceSet with RNA-specific methods for fetching and storing calculate_gc RNASet.calculate_gc(self) Arguments Returns from_db RNASet.from_db(self) Arguments Returns AminoAcidsSet AminoAcidsSet(self, sequences, start_index=None) SequenceSet with AminoAcids-specific methods for fetching and storing from_db AminoAcidsSet.from_db(self) Arguments Returns","title":"SequenceSet"},{"location":"docs/Variant/","text":"Variant Variant(self, /, *args, **kwargs) Properties","title":"Variant"},{"location":"docs/VariantTable/","text":"VariantTable VariantTable(self) Properties from_file VariantTable.from_file(path, filetype=None, start_index=1) Arguments Returns from_db VariantTable.from_db() Arguments Returns save_as VariantTable.save_as(self, path, filetype=None, overwrite_existing=False) Arguments Returns","title":"VariantTable"}]}